"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[490],{8294:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>a,default:()=>m,frontMatter:()=>c,metadata:()=>l,toc:()=>d});var r=n(4848),i=n(8453),s=n(1122);n(1432);const c={title:"High-Level C++ for Accelerated Clusters"},a=void 0,l={type:"mdx",permalink:"/",source:"@site/src/pages/index.mdx",title:"High-Level C++ for Accelerated Clusters",description:"<ThemedImage",frontMatter:{title:"High-Level C++ for Accelerated Clusters"},unlisted:!1},o={},d=[];function u(e){const t={a:"a",code:"code",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("div",{style:{textAlign:"center"},children:(0,r.jsx)(s.A,{sources:{light:"img/celerity_logo.svg",dark:"img/celerity_logo_dark.svg"},alt:"Celerity Logo"})}),"\n",(0,r.jsxs)("div",{className:"text--center padding-vert--lg",children:[(0,r.jsxs)(t.p,{children:["Celerity aims to bring the power and ease of use of\n",(0,r.jsx)(t.a,{href:"https://www.khronos.org/sycl",children:"SYCL"})," to distributed memory accelerator\nclusters."]}),(0,r.jsx)("a",{href:"/docs/getting-started",className:"button button--outline button--primary",children:"Get Started"})]}),"\n",(0,r.jsx)("div",{className:"welcome-code-sample",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",metastring:'title="Complete Celerity code sample for distributed multi-GPU matrix-vector multiplication"',children:"#include <celerity.h>\nusing namespace celerity;\n\n// naive, but distributed matrix-vector multiplication!\nint main() {\n    // (1) declare virtualized input and output buffers\n    constexpr size_t size = 256;\n    buffer<float, 2> matrix{{size, size}};\n    buffer<float, 1> vector{{size}};\n    buffer<float, 1> result{{size}};\n\n    distr_queue q;\n    q.submit([&](handler &cgh) {\n        // (2) specify data access patterns to enable distributed execution\n        accessor m(matrix, cgh, [size](chunk<1> chnk) {\n            return subrange<2>({chnk.offset[0], 0}, {chnk.range[0], size});\n        }, read_only);\n        accessor v(vector, cgh, access::one_to_one(), read_only);\n        accessor r(result, cgh, access::one_to_one(), write_only, no_init);\n\n        // (3) launch the parallel computation\n        cgh.parallel_for(range<1>(size), [=](item<1> item) {\n            r[item] = 0;\n            for (size_t i = 0; i < size; ++i) {\n                r[item] += m[item.get_id(0)][i] * v[i];\n            }\n        });\n    });\n}\n"})})})]})}function m(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}}}]);