"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[728],{878:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var r=i(4848),t=i(8453);const s={id:"range-mappers",title:"Expressing Data Dependencies with Range Mappers",sidebar_label:"Range Mappers"},a=void 0,o={id:"range-mappers",title:"Expressing Data Dependencies with Range Mappers",description:"In order for Celerity to be able to split kernel executions across an",source:"@site/celerity-runtime/docs/range-mappers.md",sourceDirName:".",slug:"/range-mappers",permalink:"/docs/range-mappers",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Fabian Knorr",lastUpdatedAt:1689266617e3,frontMatter:{id:"range-mappers",title:"Expressing Data Dependencies with Range Mappers",sidebar_label:"Range Mappers"},sidebar:"docs",previous:{title:"Tutorial",permalink:"/docs/tutorial"},next:{title:"Host Tasks",permalink:"/docs/host-tasks"}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"Usage",id:"usage",level:3},{value:"Getting an Intuition",id:"getting-an-intuition",level:3},{value:"Built-in Range Mappers",id:"built-in-range-mappers",level:2},{value:"One-to-one",id:"one-to-one",level:3},{value:"Slice",id:"slice",level:3},{value:"Neighborhood",id:"neighborhood",level:3},{value:"Fixed",id:"fixed",level:3},{value:"All",id:"all",level:3},{value:"Validity Requirements",id:"validity-requirements",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["In order for Celerity to be able to split kernel executions across an\narbitrary number of worker nodes, it needs to be able to determine how a\nkernel accesses a buffer. More specifically, it needs a way of knowing how\neach individual work item intends to access the buffer both spatially (i.e.,\nat which indices) as well as in what way (e.g. for reading, writing and so\non). While for the latter SYCL's access modes are sufficient, the former\nrequires an API extension that we call ",(0,r.jsx)(n.strong,{children:"range mappers"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(n.p,{children:["Range mappers are functors that map a portion of kernel execution, a\nso-called ",(0,r.jsx)(n.strong,{children:"chunk"}),", to a subrange of a buffer that is being accessed by the\nkernel. More concretely, for a kernel with iteration-range dimensionality\n",(0,r.jsx)(n.code,{children:"KernelDims"})," that accesses a buffer with dimensionality ",(0,r.jsx)(n.code,{children:"BufferDims"}),", the range\nmapper must be callable with at least one of the following signatures:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"celerity::subrange<BufferDims> range_mapper(celerity::chunk<KernelDims> chnk);\ncelerity::subrange<BufferDims> range_mapper(celerity::chunk<KernelDims> chnk,\n        celerity::range<BufferDims> buffer_range);\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"KernelDims"})," and ",(0,r.jsx)(n.code,{children:"BufferDims"})," can either be constants matching the kernel\nand buffer definitions or originate from template parameters.\nIn general, the dimensionality of a kernel does not have to match that of\nthe buffer(s) it operates on. For example, a two-dimensional kernel might\naccess a one-dimensional buffer, or vice-versa."]}),"\n",(0,r.jsx)(n.h3,{id:"usage",children:"Usage"}),"\n",(0,r.jsxs)(n.p,{children:["Range mappers are passed as the third argument when constructing a\n",(0,r.jsx)(n.code,{children:"celerity::accessor"}),". This means that the spatial accessing\nbehavior of a kernel can vary from buffer to buffer. For example, the\nfollowing command group specifies two different range mappers (whose\ndefinition is omitted) for buffers ",(0,r.jsx)(n.code,{children:"buf_a"})," and ",(0,r.jsx)(n.code,{children:"buf_b"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"queue.submit([&](celerity::handler& cgh) {\n\tcelerity::accessor r_a{cgh, buf_a, my_mapper, celerity::read_only};\n\tcelerity::accessor dw_b{cgh, buf_b, other_mapper, celerity::write_only, celerity::no_init};\n\n    cgh.parallel_for(...);\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"getting-an-intuition",children:"Getting an Intuition"}),"\n",(0,r.jsxs)(n.p,{children:["A useful way of thinking about kernel chunks is as a collection of individual\nkernel threads, or ",(0,r.jsx)(n.em,{children:"work items"}),". Each work item is associated with a unique\none-, two-, or three-dimensional index. Together, they span the entire global\nexecution range for a kernel call. If you can determine the spatial buffer\naccess behavior for each work item, all that's left to do is to express it in\nsuch a way that it can be computed for entire collections of work items (i.e.,\nchunks) at a time. The resulting subrange should then be the union of each\nindiviual work items' requirements."]}),"\n",(0,r.jsx)(n.p,{children:"Arguably the simplest of such mappings would be for a kernel that only\naccesses a buffer at the very same index as the index of its work item. Such\na one-to-one mapping could be implemented by simply returning the entire\nchunk without changes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template<int Dims>\ncelerity::subrange<Dims> my_one_to_one(celerity::chunk<Dims> chnk) {\n    return celerity::subrange<Dims>(chnk);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Note that in order for this to work, the dimensionality of both the kernel\nand the buffer must match."}),"\n",(0,r.jsxs)(n.p,{children:["Since this is such a common pattern, Celerity provides ",(0,r.jsx)(n.em,{children:"built-in range\nmappers"})," for one-to-one mappings and other frequently used patterns. See\n",(0,r.jsx)(n.a,{href:"/docs/range-mappers#built-in-range-mappers",children:"Built-in Range Mappers"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"built-in-range-mappers",children:"Built-in Range Mappers"}),"\n",(0,r.jsxs)(n.p,{children:["Celerity currently ships with the following built-in range mappers (all under\nthe ",(0,r.jsx)(n.code,{children:"celerity::access"})," namespace):"]}),"\n",(0,r.jsx)(n.h3,{id:"one-to-one",children:"One-to-one"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"one_to_one"})," range mapper directly maps the offset and range of a given\nchunk to a subrange. This requires that the dimensionality of the kernel and\nbuffer matches."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"struct celerity::access::one_to_one {\n    template <int Dims>\n    subrange<Dims> operator()(chunk<Dims> chnk) const;\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"slice",children:"Slice"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"slice"})," range mapper allows to extend the range of a chunk along a given\ndimension indefinitely, thus selecting an entire slice of a buffer in that\ndimension. This requires that the dimensionality of the kernel and buffer\nmatches. A common use case for this range mapper is dense matrix\nmultiplication."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template <int Dims>\nstruct celerity::access::slice {\n    explicit slice(size_t dim_idx);\n\n    subrange<Dims> operator()(chunk<Dims> chnk) const;\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"neighborhood",children:"Neighborhood"}),"\n",(0,r.jsx)(n.p,{children:"The neighborhood range mapper allows to select a specified number of indices\naround a given index in every dimension. Neighborhoods are clamped to the\nboundaries of the buffer. This range mapper is commonly used for stencil\ncodes."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template <int Dims>\nstruct celerity::access::neighborhood {\n    neighborhood(size_t dim0);\n    /* only available if Dims >= 2 */\n    neighborhood(size_t dim0, size_t dim1);\n    /* only available if Dims == 3 */\n    neighborhood(size_t dim0, size_t dim1, size_t dim2);\n\n    subrange<Dims> operator()(chunk<Dims> chnk) const;\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"fixed",children:"Fixed"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"fixed"})," range mapper allows to specify a fixed subrange that each chunk\nrequires, i.e., independently of the input chunk. This range mapper is\ncommonly used in situations where all worker nodes need access to a fixed\nsection of a buffer, for example a filter to apply during a convolution."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"template <int BufferDims>\nstruct celerity::access::fixed {\n    fixed(subrange<BufferDims> sr);\n\n    template <int KernelDims>\n    subrange<BufferDims> operator()(chunk<KernelDims>) const;\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"all",children:"All"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"all"})," range mapper selects the entire buffer, regardless of the input\nchunk. This is a special case of the ",(0,r.jsx)(n.code,{children:"fixed"})," range mapper and is provided for\nconvenience."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"struct celerity::access::all {\n    template <int KernelDims, int BufferDims>\n    subrange<BufferDims> operator()(chunk<KernelDims>, range<BufferDims>) const;\n};\n"})}),"\n",(0,r.jsx)(n.h2,{id:"validity-requirements",children:"Validity Requirements"}),"\n",(0,r.jsx)(n.p,{children:"Range mappers must fulfill certain requirements in order to be considered\nvalid."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A range mapper must be ",(0,r.jsx)(n.em,{children:"monotonic"}),", meaning that the result for any given\nwork item must not change depending on the other items, i.e., the given input\nchunk. Given the kernel domain ",(0,r.jsx)(n.code,{children:"K"}),", a buffer domain ",(0,r.jsx)(n.code,{children:"B"})," and a range mapper\n",(0,r.jsx)(n.code,{children:"r: K -> B"}),", it must hold that ",(0,r.jsx)(n.code,{children:"for all a,b that are subsets of K: if a is a subset of b, then r(a) is a subset of r(b)"}),".\nIn other words, if two chunks share one or more work items, their resulting\ndata requirements must both include the requirements of the shared items."]}),"\n",(0,r.jsx)(n.li,{children:"A range mapper must never assume a particular number of chunks. Part of the\nreason range mappers exist in the first place is to alleviate users of having\nto think about how work and data is to be split."}),"\n",(0,r.jsxs)(n.li,{children:["For producer accesses (that is, everything except\n",(0,r.jsx)(n.code,{children:"celerity::access_mode::read"}),"), the output of a range mapper must not overlap."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Range mappers that do not satisfy all of the above points cause undefined\nbehavior. Note that it is perfectly valid for range mappers to return an\nempty subrange for certain chunks."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var r=i(6540);const t={},s=r.createContext(t);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);