"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[805],{6791:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var i=t(4848),r=t(8453);const s={id:"pitfalls",title:"Common Pitfalls",sidebar_label:"Common Pitfalls"},c=void 0,a={id:"pitfalls",title:"Common Pitfalls",description:"There are a few pitfalls that are commonly encountered when first getting",source:"@site/celerity-runtime/docs/pitfalls.md",sourceDirName:".",slug:"/pitfalls",permalink:"/docs/pitfalls",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"Fabian Knorr",lastUpdatedAt:1700167132e3,frontMatter:{id:"pitfalls",title:"Common Pitfalls",sidebar_label:"Common Pitfalls"},sidebar:"docs",previous:{title:"Reductions",permalink:"/docs/reductions"},next:{title:"Issues & Limitations",permalink:"/docs/issues-and-limitations"}},o={},l=[{value:"Incorrectly Specified Range Mappers",id:"incorrectly-specified-range-mappers",level:2},{value:"Out-Of-Bounds Accesses",id:"out-of-bounds-accesses",level:3},{value:"Overlapping Writes",id:"overlapping-writes",level:3},{value:"Illegal Reference Captures in Kernel and Host Task Functions",id:"illegal-reference-captures-in-kernel-and-host-task-functions",level:2},{value:"Diverging Host-Execution on Different Nodes",id:"diverging-host-execution-on-different-nodes",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"There are a few pitfalls that are commonly encountered when first getting\nstarted with Celerity."}),"\n",(0,i.jsx)(n.h2,{id:"incorrectly-specified-range-mappers",children:"Incorrectly Specified Range Mappers"}),"\n",(0,i.jsxs)(n.p,{children:["Celerity requires ",(0,i.jsx)(n.a,{href:"/docs/range-mappers",children:"range mappers"})," to be specified on every accessor definition\nin order to maintain data coherence across the cluster. When a kernel exhibits a complex data\naccess pattern, two core requirements are easy to violate from user code \u2013 even when using\nCelerity's built-in range mappers."]}),"\n",(0,i.jsx)(n.h3,{id:"out-of-bounds-accesses",children:"Out-Of-Bounds Accesses"}),"\n",(0,i.jsxs)(n.p,{children:["A work item ",(0,i.jsx)(n.code,{children:"item"})," must never access the buffer outside the range of ",(0,i.jsx)(n.code,{children:"range_mapper(chunk)"}),",\nwhere ",(0,i.jsx)(n.code,{children:"chunk"})," is any chunk of the iteration space that contains ",(0,i.jsx)(n.code,{children:"item"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// INCORRECT example: access pattern inside the kernel does not follow the range mapper\ncelerity::buffer<float, 1> buf({256});\ncelerity::distr_queue().submit([&](celerity::handler &cgh) {\n    celerity::accessor acc(buf, cgh, celerity::access::one_to_one(), celerity::read_write);\n    cgh.parallel_for(celerity::range<1>(128), [=](celerity::item<1> item) {\n        // OUT-OF-BOUNDS ACCESS: `one_to_one` means `item` must only access `acc[item]`\n        acc[item] += acc[item.get_id(0) + 128];\n    });\n});\n"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Out-of-bounds accesses can be detected at runtime by enabling the\n",(0,i.jsx)(n.code,{children:"CELERITY_ACCESSOR_BOUNDARY_CHECK"})," CMake option at the cost of some runtime\noverhead (enabled by default in debug builds)."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"overlapping-writes",children:"Overlapping Writes"}),"\n",(0,i.jsxs)(n.p,{children:["Range mappers for ",(0,i.jsx)(n.code,{children:"write_only"})," or ",(0,i.jsx)(n.code,{children:"read_write"})," accessors must never produce overlapping buffer\nranges for non-overlapping chunks of the iteration space."]}),"\n",(0,i.jsxs)(n.p,{children:["A likely beginner mistake is to violate the second constraint when implementing a ",(0,i.jsx)(n.strong,{children:"stencil code"}),".\nThe first intuition might be to operate on a single buffer using a ",(0,i.jsx)(n.code,{children:"read_write"})," accessor together\nwith a ",(0,i.jsx)(n.code,{children:"neighborhood"})," range mapper like so:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// INCORRECT stencil example\ncelerity::distr_queue q;\ncelerity::buffer<float, 2> buf({256, 256});\nfor (int i = 0; i < N; ++i) {\n    q.submit([&](celerity::handler &cgh) {\n        // ILLEGAL RANGE MAPPER: `neighborhood` can not be used on a writing access\n        celerity::accessor acc(buf, cgh, celerity::access::neighborhood(1, 1),\n                celerity::read_write);\n        cgh.parallel_for(buf.get_range(), [=](celerity::item<1> item) {\n            acc[item] = acc[...] + acc[...] + /* ... stencil code */;\n        });\n    });\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Intstead, these patterns must be implemented using a separate ",(0,i.jsx)(n.code,{children:"neighborhood"})," read-access and\n",(0,i.jsx)(n.code,{children:"one_to_one"})," write-access ",(0,i.jsx)(n.em,{children:"on two separate"})," buffers:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// correct stencil code\ncelerity::distr_queue q;\ncelerity::buffer<float, 2> input({256, 256});\ncelerity::buffer<float, 2> output({256, 256}); // double buffering\nfor (int i = 0; i < N; ++i) {\n    q.submit([&](celerity::handler &cgh) {\n        celerity::accessor read(input, cgh, celerity::access::neighborhood(1, 1),\n                celerity::read_only);\n        celerity::accessor write(output, cgh, celerity::access::one_to_one(),\n                celerity::write_only, celerity::no_init);\n        cgh.parallel_for(output.get_range(), [=](celerity::item<2> item) {\n            write[item] = read[...] + read[...] + /* ... stencil code */;\n        });\n    });\n    if (i + 1 < N) std::swap(input, output); // swapping buffers has trivial cost!\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Note that this is not just a Celerity limitation, but inherent to the implementation of stencils\non GPUs, which must avoid races between reads and writes through a strategy like double-buffering\nanyway."}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["None of the ",(0,i.jsx)(n.code,{children:"all"}),", ",(0,i.jsx)(n.code,{children:"fixed"}),", ",(0,i.jsx)(n.code,{children:"neighborhood"})," or ",(0,i.jsx)(n.code,{children:"slice"})," built-in range mappers\ncan be used for a writing access (unless the kernel only operates on a single\nwork item)."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"illegal-reference-captures-in-kernel-and-host-task-functions",children:"Illegal Reference Captures in Kernel and Host Task Functions"}),"\n",(0,i.jsxs)(n.p,{children:["Celerity tasks submitted to the ",(0,i.jsx)(n.code,{children:"celerity::distr_queue"})," are executed\n",(0,i.jsx)(n.em,{children:"asynchronously"}),' at a later point in time. This means that the stack\nsurrounding a command function ("kernel") may have been unwound by the time it\nis being invoked.']}),"\n",(0,i.jsx)(n.p,{children:"While Celerity and the underlying SYCL implementation will try to detect and\nprevent certain types of common errors (for example capturing accessors by\nreference), not all mistakes can be caught reliably."}),"\n",(0,i.jsxs)(n.p,{children:["In particular when using ",(0,i.jsx)(n.a,{href:"/docs/host-tasks",children:"host tasks"}),", it is important to ensure\nthat all values that are captured by reference outlive the task:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'int global_variable = 22;\n\nvoid some_function(celerity::distr_queue& q) {\n    int local_variable = 42;\n    q.submit([&](celerity::handler& cgh) {\n        cgh.host_task([&] {\n            printf("%d\\n", global_variable); // safe, global variable outlives task\n            printf("%d\\n", local_variable); // dangling reference!\n        });\n    });\n}\n'})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Celerity supports APIs that can replace most if not all uses for reference captures.\nSee ",(0,i.jsx)(n.code,{children:"celerity::distr_queue::fence"}),", ",(0,i.jsx)(n.code,{children:"celerity::experimental::host_object"})," and\n",(0,i.jsx)(n.code,{children:"celerity::experimental::side_effect"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"diverging-host-execution-on-different-nodes",children:"Diverging Host-Execution on Different Nodes"}),"\n",(0,i.jsxs)(n.p,{children:["Each Celerity process that is started as part of a single cluster execution\n(i.e., using ",(0,i.jsx)(n.code,{children:"mpirun"})," or similar) ",(0,i.jsx)(n.em,{children:"must"})," execute the exact same host code (pertaining to any Celerity API interactions).\nThis means that for example something like this is ",(0,i.jsx)(n.em,{children:"illegal"})," and will result\nin undefined behavior:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"if(rand() > 1337) {\n    celerity::buffer<float, 2> my_buffer(...);\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>a});var i=t(6540);const r={},s=i.createContext(r);function c(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);